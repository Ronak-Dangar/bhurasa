{
    "sourceFile": "app/actions/orders.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1763302822984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1765424201623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,9 +104,9 @@\n   const supabase = await createSupabaseServerClient();\r\n   \r\n   const { data, error } = await supabase\r\n     .from(\"inventory_items\")\r\n-    .select(\"*\")\r\n+    .select(\"id, item_name, item_type, unit, avg_cost, selling_price, stock_level\")\r\n     .eq(\"item_type\", \"finished_good\")\r\n     .gt(\"stock_level\", 0)\r\n     .order(\"item_name\", { ascending: true });\r\n \r\n@@ -131,4 +131,67 @@\n   }\r\n \r\n   return { success: true, data };\r\n }\r\n+\r\n+/**\r\n+ * Create a new delivery agent with auth.users entry + profile\r\n+ * Auto-generates a temporary password (agent can reset later)\r\n+ */\r\n+export async function createDeliveryAgent(formData: {\r\n+  name: string;\r\n+  email: string;\r\n+  phone: string;\r\n+}) {\r\n+  const supabase = await createSupabaseServerClient();\r\n+\r\n+  // Generate a temporary password (8 chars random)\r\n+  const tempPassword = Math.random().toString(36).slice(-8) + \"Aa1!\";\r\n+\r\n+  // Step 1: Create auth user using admin client\r\n+  const { data: authData, error: authError } = await supabase.auth.admin.createUser({\r\n+    email: formData.email,\r\n+    password: tempPassword,\r\n+    email_confirm: true, // Auto-confirm email\r\n+    user_metadata: {\r\n+      full_name: formData.name,\r\n+      phone: formData.phone,\r\n+    },\r\n+  });\r\n+\r\n+  if (authError || !authData.user) {\r\n+    return {\r\n+      success: false,\r\n+      error: authError?.message || \"Failed to create auth user\",\r\n+    };\r\n+  }\r\n+\r\n+  // Step 2: Insert profile with delivery_agent role\r\n+  const { error: profileError } = await supabase.from(\"profiles\").insert([\r\n+    {\r\n+      id: authData.user.id,\r\n+      full_name: formData.name,\r\n+      phone: formData.phone,\r\n+      role: \"delivery_agent\",\r\n+    },\r\n+  ]);\r\n+\r\n+  if (profileError) {\r\n+    // Cleanup: delete the auth user if profile creation fails\r\n+    await supabase.auth.admin.deleteUser(authData.user.id);\r\n+    return {\r\n+      success: false,\r\n+      error: `Profile creation failed: ${profileError.message}`,\r\n+    };\r\n+  }\r\n+\r\n+  revalidatePath(\"/orders/new\");\r\n+  return {\r\n+    success: true,\r\n+    data: {\r\n+      id: authData.user.id,\r\n+      full_name: formData.name,\r\n+      tempPassword, // Return for display (optional)\r\n+    },\r\n+  };\r\n+}\r\n+\r\n"
                },
                {
                    "date": 1765451291481,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n \"use server\";\r\n \r\n import { createSupabaseServerClient } from \"@/lib/supabase/server\";\r\n+import { createClient } from \"@supabase/supabase-js\";\r\n import { revalidatePath } from \"next/cache\";\r\n \r\n export async function createOrder(formData: {\r\n   customerId: string;\r\n@@ -135,21 +136,32 @@\n \r\n /**\r\n  * Create a new delivery agent with auth.users entry + profile\r\n  * Auto-generates a temporary password (agent can reset later)\r\n+ * Uses Service Role Key to bypass RLS and user restrictions\r\n  */\r\n export async function createDeliveryAgent(formData: {\r\n   name: string;\r\n   email: string;\r\n   phone: string;\r\n }) {\r\n-  const supabase = await createSupabaseServerClient();\r\n+  // Create admin client with Service Role Key (bypasses all RLS and auth restrictions)\r\n+  const supabaseAdmin = createClient(\r\n+    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n+    process.env.SUPABASE_SERVICE_ROLE_KEY!,\r\n+    {\r\n+      auth: {\r\n+        autoRefreshToken: false,\r\n+        persistSession: false,\r\n+      },\r\n+    }\r\n+  );\r\n \r\n   // Generate a temporary password (8 chars random)\r\n   const tempPassword = Math.random().toString(36).slice(-8) + \"Aa1!\";\r\n \r\n   // Step 1: Create auth user using admin client\r\n-  const { data: authData, error: authError } = await supabase.auth.admin.createUser({\r\n+  const { data: authData, error: authError } = await supabaseAdmin.auth.admin.createUser({\r\n     email: formData.email,\r\n     password: tempPassword,\r\n     email_confirm: true, // Auto-confirm email\r\n     user_metadata: {\r\n@@ -164,10 +176,10 @@\n       error: authError?.message || \"Failed to create auth user\",\r\n     };\r\n   }\r\n \r\n-  // Step 2: Insert profile with delivery_agent role\r\n-  const { error: profileError } = await supabase.from(\"profiles\").insert([\r\n+  // Step 2: Insert profile with delivery_agent role (using admin client to bypass RLS)\r\n+  const { error: profileError } = await supabaseAdmin.from(\"profiles\").insert([\r\n     {\r\n       id: authData.user.id,\r\n       full_name: formData.name,\r\n       phone: formData.phone,\r\n@@ -176,9 +188,9 @@\n   ]);\r\n \r\n   if (profileError) {\r\n     // Cleanup: delete the auth user if profile creation fails\r\n-    await supabase.auth.admin.deleteUser(authData.user.id);\r\n+    await supabaseAdmin.auth.admin.deleteUser(authData.user.id);\r\n     return {\r\n       success: false,\r\n       error: `Profile creation failed: ${profileError.message}`,\r\n     };\r\n"
                },
                {
                    "date": 1765690062927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,10 @@\n import { createSupabaseServerClient } from \"@/lib/supabase/server\";\r\n import { createClient } from \"@supabase/supabase-js\";\r\n import { revalidatePath } from \"next/cache\";\r\n \r\n-export async function createOrder(formData: {\r\n+export async function saveOrder(formData: {\r\n+  orderId?: string;\r\n   customerId: string;\r\n   paymentStatus: \"cod\" | \"prepaid\";\r\n   deliveryAgentId?: string;\r\n   items: Array<{\r\n@@ -30,56 +31,135 @@\n     const liters = literMatch ? parseInt(literMatch[1]) : 1;\r\n     return sum + liters * item.quantity;\r\n   }, 0);\r\n \r\n-  // Create the order\r\n-  const { data: order, error: orderError } = await supabase\r\n-    .from(\"orders\")\r\n-    .insert([\r\n-      {\r\n+  let order;\r\n+\r\n+  if (formData.orderId) {\r\n+    // UPDATE MODE: Edit existing order\r\n+    \r\n+    // Step 1: Delete existing order items\r\n+    const { error: deleteItemsError } = await supabase\r\n+      .from(\"order_items\")\r\n+      .delete()\r\n+      .eq(\"order_id\", formData.orderId);\r\n+\r\n+    if (deleteItemsError) {\r\n+      return { success: false, error: `Failed to delete old items: ${deleteItemsError.message}` };\r\n+    }\r\n+\r\n+    // Step 2: Update the order\r\n+    const { data: updatedOrder, error: updateError } = await supabase\r\n+      .from(\"orders\")\r\n+      .update({\r\n         customer_id: formData.customerId,\r\n-        status: \"pending\",\r\n         payment_status: formData.paymentStatus,\r\n         total_amount: totalAmount,\r\n         total_liters: totalLiters,\r\n         assigned_agent: formData.deliveryAgentId || null,\r\n-      },\r\n-    ])\r\n-    .select()\r\n-    .single();\r\n+      })\r\n+      .eq(\"id\", formData.orderId)\r\n+      .select()\r\n+      .single();\r\n \r\n-  if (orderError) {\r\n-    return { success: false, error: orderError.message };\r\n-  }\r\n+    if (updateError) {\r\n+      return { success: false, error: updateError.message };\r\n+    }\r\n \r\n-  // Create order items\r\n-  const orderItems = formData.items.map((item) => ({\r\n-    order_id: order.id,\r\n-    product_id: item.productId,\r\n-    product_name: item.productName,\r\n-    quantity: item.quantity,\r\n-    unit_price: item.unitPrice,\r\n-  }));\r\n+    order = updatedOrder;\r\n \r\n-  const { error: itemsError } = await supabase\r\n-    .from(\"order_items\")\r\n-    .insert(orderItems);\r\n+    // Step 3: Insert new order items\r\n+    const orderItems = formData.items.map((item) => ({\r\n+      order_id: order.id,\r\n+      product_id: item.productId,\r\n+      product_name: item.productName,\r\n+      quantity: item.quantity,\r\n+      unit_price: item.unitPrice,\r\n+    }));\r\n \r\n-  if (itemsError) {\r\n-    // Rollback order if items fail\r\n-    await supabase.from(\"orders\").delete().eq(\"id\", order.id);\r\n-    return { success: false, error: itemsError.message };\r\n-  }\r\n+    const { error: itemsError } = await supabase\r\n+      .from(\"order_items\")\r\n+      .insert(orderItems);\r\n \r\n-  // Create delivery assignment if agent is assigned\r\n-  if (formData.deliveryAgentId) {\r\n-    await supabase.from(\"delivery_assignments\").insert([\r\n-      {\r\n-        order_id: order.id,\r\n-        delivery_agent_id: formData.deliveryAgentId,\r\n-        scheduled_for: new Date().toISOString(),\r\n-      },\r\n-    ]);\r\n+    if (itemsError) {\r\n+      return { success: false, error: itemsError.message };\r\n+    }\r\n+\r\n+    // Step 4: Update delivery assignment\r\n+    if (formData.deliveryAgentId) {\r\n+      // Delete old assignment\r\n+      await supabase\r\n+        .from(\"delivery_assignments\")\r\n+        .delete()\r\n+        .eq(\"order_id\", order.id);\r\n+\r\n+      // Create new assignment\r\n+      await supabase.from(\"delivery_assignments\").insert([\r\n+        {\r\n+          order_id: order.id,\r\n+          delivery_agent_id: formData.deliveryAgentId,\r\n+          scheduled_for: new Date().toISOString(),\r\n+        },\r\n+      ]);\r\n+    } else {\r\n+      // Remove assignment if agent was unassigned\r\n+      await supabase\r\n+        .from(\"delivery_assignments\")\r\n+        .delete()\r\n+        .eq(\"order_id\", order.id);\r\n+    }\r\n+  } else {\r\n+    // CREATE MODE: New order\r\n+    const { data: newOrder, error: orderError } = await supabase\r\n+      .from(\"orders\")\r\n+      .insert([\r\n+        {\r\n+          customer_id: formData.customerId,\r\n+          status: \"pending\",\r\n+          payment_status: formData.paymentStatus,\r\n+          total_amount: totalAmount,\r\n+          total_liters: totalLiters,\r\n+          assigned_agent: formData.deliveryAgentId || null,\r\n+        },\r\n+      ])\r\n+      .select()\r\n+      .single();\r\n+\r\n+    if (orderError) {\r\n+      return { success: false, error: orderError.message };\r\n+    }\r\n+\r\n+    order = newOrder;\r\n+\r\n+    // Create order items\r\n+    const orderItems = formData.items.map((item) => ({\r\n+      order_id: order.id,\r\n+      product_id: item.productId,\r\n+      product_name: item.productName,\r\n+      quantity: item.quantity,\r\n+      unit_price: item.unitPrice,\r\n+    }));\r\n+\r\n+    const { error: itemsError } = await supabase\r\n+      .from(\"order_items\")\r\n+      .insert(orderItems);\r\n+\r\n+    if (itemsError) {\r\n+      // Rollback order if items fail\r\n+      await supabase.from(\"orders\").delete().eq(\"id\", order.id);\r\n+      return { success: false, error: itemsError.message };\r\n+    }\r\n+\r\n+    // Create delivery assignment if agent is assigned\r\n+    if (formData.deliveryAgentId) {\r\n+      await supabase.from(\"delivery_assignments\").insert([\r\n+        {\r\n+          order_id: order.id,\r\n+          delivery_agent_id: formData.deliveryAgentId,\r\n+          scheduled_for: new Date().toISOString(),\r\n+        },\r\n+      ]);\r\n+    }\r\n   }\r\n \r\n   revalidatePath(\"/orders/new\");\r\n   revalidatePath(\"/\");\r\n@@ -206,4 +286,169 @@\n     },\r\n   };\r\n }\r\n \r\n+/**\r\n+ * Get order queue with filters\r\n+ * Returns orders with full details (customer, items, agent, etc.)\r\n+ */\r\n+export async function getOrderQueue(statusFilter: \"pending\" | \"delivered\") {\r\n+  const supabase = await createSupabaseServerClient();\r\n+\r\n+  // Build status filter\r\n+  const statuses = statusFilter === \"pending\" ? [\"pending\", \"processing\"] : [\"delivered\"];\r\n+\r\n+  // Fetch orders\r\n+  const { data: orders, error: ordersError } = await supabase\r\n+    .from(\"orders\")\r\n+    .select(`\r\n+      id,\r\n+      customer_id,\r\n+      status,\r\n+      payment_status,\r\n+      total_amount,\r\n+      total_liters,\r\n+      assigned_agent,\r\n+      created_at,\r\n+      customers!inner(id, name, phone, address),\r\n+      profiles(id, full_name)\r\n+    `)\r\n+    .in(\"status\", statuses)\r\n+    .order(\"created_at\", { ascending: false });\r\n+\r\n+  if (ordersError) {\r\n+    return { success: false, error: ordersError.message };\r\n+  }\r\n+\r\n+  // Fetch order items for all orders\r\n+  const orderIds = orders?.map((o) => o.id) || [];\r\n+  const { data: orderItems } = await supabase\r\n+    .from(\"order_items\")\r\n+    .select(\"order_id, product_id, product_name, quantity, unit_price\")\r\n+    .in(\"order_id\", orderIds);\r\n+\r\n+  // Map items to orders\r\n+  const ordersWithItems = orders?.map((order) => ({\r\n+    id: order.id,\r\n+    customerId: order.customer_id,\r\n+    customerName: order.customers?.name || \"Unknown\",\r\n+    customerPhone: order.customers?.phone || \"\",\r\n+    customerAddress: order.customers?.address || \"\",\r\n+    status: order.status,\r\n+    paymentStatus: order.payment_status,\r\n+    totalAmount: order.total_amount,\r\n+    totalLiters: order.total_liters,\r\n+    agentId: order.assigned_agent,\r\n+    agentName: order.profiles?.full_name || \"Unassigned\",\r\n+    createdAt: order.created_at,\r\n+    items: orderItems?.filter((item) => item.order_id === order.id) || [],\r\n+  }));\r\n+\r\n+  return { success: true, data: ordersWithItems };\r\n+}\r\n+\r\n+/**\r\n+ * Get real-time order statistics and production requirements\r\n+ * Returns order counts by status/payment and inventory gaps for pending orders\r\n+ */\r\n+export async function getOrderStats() {\r\n+  const supabase = await createSupabaseServerClient();\r\n+\r\n+  // Step 1: Get order counts\r\n+  const [pendingPrepaidResult, pendingCODResult, deliveredResult] = await Promise.all([\r\n+    supabase\r\n+      .from(\"orders\")\r\n+      .select(\"id\", { count: \"exact\", head: true })\r\n+      .eq(\"status\", \"pending\")\r\n+      .eq(\"payment_status\", \"prepaid\"),\r\n+    supabase\r\n+      .from(\"orders\")\r\n+      .select(\"id\", { count: \"exact\", head: true })\r\n+      .eq(\"status\", \"pending\")\r\n+      .eq(\"payment_status\", \"cod\"),\r\n+    supabase\r\n+      .from(\"orders\")\r\n+      .select(\"id\", { count: \"exact\", head: true })\r\n+      .eq(\"status\", \"delivered\"),\r\n+  ]);\r\n+\r\n+  const orderCounts = {\r\n+    pendingPrepaid: pendingPrepaidResult.count || 0,\r\n+    pendingCOD: pendingCODResult.count || 0,\r\n+    delivered: deliveredResult.count || 0,\r\n+  };\r\n+\r\n+  // Step 2: Get production requirements for pending orders\r\n+  // Fetch all pending order IDs\r\n+  const { data: pendingOrders } = await supabase\r\n+    .from(\"orders\")\r\n+    .select(\"id\")\r\n+    .eq(\"status\", \"pending\");\r\n+\r\n+  if (!pendingOrders || pendingOrders.length === 0) {\r\n+    return {\r\n+      success: true,\r\n+      data: {\r\n+        orderCounts,\r\n+        productionRequirements: [],\r\n+      },\r\n+    };\r\n+  }\r\n+\r\n+  const pendingOrderIds = pendingOrders.map((o) => o.id);\r\n+\r\n+  // Fetch all order items for pending orders\r\n+  const { data: orderItems, error: itemsError } = await supabase\r\n+    .from(\"order_items\")\r\n+    .select(\"product_id, product_name, quantity\")\r\n+    .in(\"order_id\", pendingOrderIds);\r\n+\r\n+  if (itemsError) {\r\n+    return { success: false, error: itemsError.message };\r\n+  }\r\n+\r\n+  // Aggregate quantities by product\r\n+  const productRequirements = new Map<string, { productName: string; required: number }>();\r\n+  \r\n+  orderItems?.forEach((item) => {\r\n+    const existing = productRequirements.get(item.product_id);\r\n+    if (existing) {\r\n+      existing.required += item.quantity;\r\n+    } else {\r\n+      productRequirements.set(item.product_id, {\r\n+        productName: item.product_name,\r\n+        required: item.quantity,\r\n+      });\r\n+    }\r\n+  });\r\n+\r\n+  // Fetch current stock levels\r\n+  const productIds = Array.from(productRequirements.keys());\r\n+  const { data: inventoryItems } = await supabase\r\n+    .from(\"inventory_items\")\r\n+    .select(\"id, stock_level\")\r\n+    .in(\"id\", productIds);\r\n+\r\n+  // Build final requirements array with deficit calculation\r\n+  const productionRequirements = Array.from(productRequirements.entries()).map(([productId, data]) => {\r\n+    const inventoryItem = inventoryItems?.find((i) => i.id === productId);\r\n+    const onHand = inventoryItem?.stock_level || 0;\r\n+    const deficit = Math.max(0, data.required - onHand);\r\n+\r\n+    return {\r\n+      productId,\r\n+      productName: data.productName,\r\n+      required: data.required,\r\n+      onHand,\r\n+      deficit,\r\n+    };\r\n+  });\r\n+\r\n+  return {\r\n+    success: true,\r\n+    data: {\r\n+      orderCounts,\r\n+      productionRequirements,\r\n+    },\r\n+  };\r\n+}\r\n+\r\n"
                },
                {
                    "date": 1765701483953,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,8 +17,24 @@\n   }>;\r\n }) {\r\n   const supabase = await createSupabaseServerClient();\r\n \r\n+  // Step 1: Fetch product details to determine order_type\r\n+  const productIds = formData.items.map(item => item.productId);\r\n+  const { data: products } = await supabase\r\n+    .from(\"inventory_items\")\r\n+    .select(\"id, item_type\")\r\n+    .in(\"id\", productIds);\r\n+\r\n+  // Determine order_type based on items\r\n+  const hasFinishedGood = products?.some(p => p.item_type === \"finished_good\");\r\n+  const orderType = hasFinishedGood ? \"oil\" : \"byproduct\";\r\n+\r\n+  // Auto-delivery logic: prepaid byproducts are delivered immediately\r\n+  const isAutoDelivered = orderType === \"byproduct\" && formData.paymentStatus === \"prepaid\";\r\n+  const orderStatus = isAutoDelivered ? \"delivered\" : \"pending\";\r\n+  const deliveredAt = isAutoDelivered ? new Date().toISOString() : null;\r\n+\r\n   // Calculate totals\r\n   const totalAmount = formData.items.reduce(\r\n     (sum, item) => sum + item.quantity * item.unitPrice,\r\n     0\r\n@@ -31,9 +47,9 @@\n     const liters = literMatch ? parseInt(literMatch[1]) : 1;\r\n     return sum + liters * item.quantity;\r\n   }, 0);\r\n \r\n-  let order;\r\n+  let order: any;\r\n \r\n   if (formData.orderId) {\r\n     // UPDATE MODE: Edit existing order\r\n     \r\n@@ -55,8 +71,11 @@\n         payment_status: formData.paymentStatus,\r\n         total_amount: totalAmount,\r\n         total_liters: totalLiters,\r\n         assigned_agent: formData.deliveryAgentId || null,\r\n+        order_type: orderType,\r\n+        status: orderStatus,\r\n+        delivered_at: deliveredAt,\r\n       })\r\n       .eq(\"id\", formData.orderId)\r\n       .select()\r\n       .single();\r\n@@ -113,13 +132,15 @@\n       .from(\"orders\")\r\n       .insert([\r\n         {\r\n           customer_id: formData.customerId,\r\n-          status: \"pending\",\r\n+          status: orderStatus,\r\n           payment_status: formData.paymentStatus,\r\n           total_amount: totalAmount,\r\n           total_liters: totalLiters,\r\n           assigned_agent: formData.deliveryAgentId || null,\r\n+          order_type: orderType,\r\n+          delivered_at: deliveredAt,\r\n         },\r\n       ])\r\n       .select()\r\n       .single();\r\n@@ -186,9 +207,9 @@\n   \r\n   const { data, error } = await supabase\r\n     .from(\"inventory_items\")\r\n     .select(\"id, item_name, item_type, unit, avg_cost, selling_price, stock_level\")\r\n-    .eq(\"item_type\", \"finished_good\")\r\n+    .in(\"item_type\", [\"finished_good\", \"byproduct\"])\r\n     .gt(\"stock_level\", 0)\r\n     .order(\"item_name\", { ascending: true });\r\n \r\n   if (error) {\r\n@@ -290,16 +311,16 @@\n /**\r\n  * Get order queue with filters\r\n  * Returns orders with full details (customer, items, agent, etc.)\r\n  */\r\n-export async function getOrderQueue(statusFilter: \"pending\" | \"delivered\") {\r\n+export async function getOrderQueue(statusFilter: \"pending\" | \"delivered\", typeFilter?: \"oil\" | \"byproduct\") {\r\n   const supabase = await createSupabaseServerClient();\r\n \r\n   // Build status filter\r\n   const statuses = statusFilter === \"pending\" ? [\"pending\", \"processing\"] : [\"delivered\"];\r\n \r\n-  // Fetch orders\r\n-  const { data: orders, error: ordersError } = await supabase\r\n+  // Build query with order_type filter\r\n+  let query = supabase\r\n     .from(\"orders\")\r\n     .select(`\r\n       id,\r\n       customer_id,\r\n@@ -308,41 +329,54 @@\n       total_amount,\r\n       total_liters,\r\n       assigned_agent,\r\n       created_at,\r\n+      order_type,\r\n       customers!inner(id, name, phone, address),\r\n       profiles(id, full_name)\r\n     `)\r\n-    .in(\"status\", statuses)\r\n-    .order(\"created_at\", { ascending: false });\r\n+    .in(\"status\", statuses);\r\n \r\n+  // Apply type filter if specified\r\n+  if (typeFilter) {\r\n+    query = query.eq(\"order_type\", typeFilter);\r\n+  }\r\n+\r\n+  const { data: orders, error: ordersError } = await query.order(\"created_at\", { ascending: false });\r\n+\r\n   if (ordersError) {\r\n     return { success: false, error: ordersError.message };\r\n   }\r\n \r\n-  // Fetch order items for all orders\r\n+  // Fetch order items (no JOIN needed, filtering by order_type above)\r\n   const orderIds = orders?.map((o) => o.id) || [];\r\n   const { data: orderItems } = await supabase\r\n     .from(\"order_items\")\r\n     .select(\"order_id, product_id, product_name, quantity, unit_price\")\r\n     .in(\"order_id\", orderIds);\r\n \r\n   // Map items to orders\r\n-  const ordersWithItems = orders?.map((order) => ({\r\n-    id: order.id,\r\n-    customerId: order.customer_id,\r\n-    customerName: order.customers?.name || \"Unknown\",\r\n-    customerPhone: order.customers?.phone || \"\",\r\n-    customerAddress: order.customers?.address || \"\",\r\n-    status: order.status,\r\n-    paymentStatus: order.payment_status,\r\n-    totalAmount: order.total_amount,\r\n-    totalLiters: order.total_liters,\r\n-    agentId: order.assigned_agent,\r\n-    agentName: order.profiles?.full_name || \"Unassigned\",\r\n-    createdAt: order.created_at,\r\n-    items: orderItems?.filter((item) => item.order_id === order.id) || [],\r\n-  }));\r\n+  const ordersWithItems = orders?.map((order: any) => {\r\n+    const customer = Array.isArray(order.customers) ? order.customers[0] : order.customers;\r\n+    const profile = Array.isArray(order.profiles) ? order.profiles[0] : order.profiles;\r\n+    \r\n+    return {\r\n+      id: order.id,\r\n+      customerId: order.customer_id,\r\n+      customerName: customer?.name || \"Unknown\",\r\n+      customerPhone: customer?.phone || \"\",\r\n+      customerAddress: customer?.address || \"\",\r\n+      status: order.status,\r\n+      paymentStatus: order.payment_status,\r\n+      totalAmount: order.total_amount,\r\n+      totalLiters: order.total_liters,\r\n+      agentId: order.assigned_agent,\r\n+      agentName: profile?.full_name || \"Unassigned\",\r\n+      createdAt: order.created_at,\r\n+      orderType: order.order_type,\r\n+      items: orderItems?.filter((item) => item.order_id === order.id) || [],\r\n+    };\r\n+  });\r\n \r\n   return { success: true, data: ordersWithItems };\r\n }\r\n \r\n"
                }
            ],
            "date": 1763302822984,
            "name": "Commit-0",
            "content": "\"use server\";\r\n\r\nimport { createSupabaseServerClient } from \"@/lib/supabase/server\";\r\nimport { revalidatePath } from \"next/cache\";\r\n\r\nexport async function createOrder(formData: {\r\n  customerId: string;\r\n  paymentStatus: \"cod\" | \"prepaid\";\r\n  deliveryAgentId?: string;\r\n  items: Array<{\r\n    productId: string;\r\n    productName: string;\r\n    quantity: number;\r\n    unitPrice: number;\r\n  }>;\r\n}) {\r\n  const supabase = await createSupabaseServerClient();\r\n\r\n  // Calculate totals\r\n  const totalAmount = formData.items.reduce(\r\n    (sum, item) => sum + item.quantity * item.unitPrice,\r\n    0\r\n  );\r\n\r\n  // Calculate total liters (assuming product names contain size info)\r\n  const totalLiters = formData.items.reduce((sum, item) => {\r\n    // Extract liters from product name (e.g., \"1L Bottle Oil\" -> 1)\r\n    const literMatch = item.productName.match(/(\\d+)L/i);\r\n    const liters = literMatch ? parseInt(literMatch[1]) : 1;\r\n    return sum + liters * item.quantity;\r\n  }, 0);\r\n\r\n  // Create the order\r\n  const { data: order, error: orderError } = await supabase\r\n    .from(\"orders\")\r\n    .insert([\r\n      {\r\n        customer_id: formData.customerId,\r\n        status: \"pending\",\r\n        payment_status: formData.paymentStatus,\r\n        total_amount: totalAmount,\r\n        total_liters: totalLiters,\r\n        assigned_agent: formData.deliveryAgentId || null,\r\n      },\r\n    ])\r\n    .select()\r\n    .single();\r\n\r\n  if (orderError) {\r\n    return { success: false, error: orderError.message };\r\n  }\r\n\r\n  // Create order items\r\n  const orderItems = formData.items.map((item) => ({\r\n    order_id: order.id,\r\n    product_id: item.productId,\r\n    product_name: item.productName,\r\n    quantity: item.quantity,\r\n    unit_price: item.unitPrice,\r\n  }));\r\n\r\n  const { error: itemsError } = await supabase\r\n    .from(\"order_items\")\r\n    .insert(orderItems);\r\n\r\n  if (itemsError) {\r\n    // Rollback order if items fail\r\n    await supabase.from(\"orders\").delete().eq(\"id\", order.id);\r\n    return { success: false, error: itemsError.message };\r\n  }\r\n\r\n  // Create delivery assignment if agent is assigned\r\n  if (formData.deliveryAgentId) {\r\n    await supabase.from(\"delivery_assignments\").insert([\r\n      {\r\n        order_id: order.id,\r\n        delivery_agent_id: formData.deliveryAgentId,\r\n        scheduled_for: new Date().toISOString(),\r\n      },\r\n    ]);\r\n  }\r\n\r\n  revalidatePath(\"/orders/new\");\r\n  revalidatePath(\"/\");\r\n  return { success: true, data: order };\r\n}\r\n\r\nexport async function getAllCustomersForDropdown() {\r\n  const supabase = await createSupabaseServerClient();\r\n  \r\n  const { data, error } = await supabase\r\n    .from(\"customers\")\r\n    .select(\"id, name, phone, address, family_size, status\")\r\n    .order(\"name\", { ascending: true });\r\n\r\n  if (error) {\r\n    return { success: false, error: error.message, data: [] };\r\n  }\r\n\r\n  return { success: true, data };\r\n}\r\n\r\nexport async function getAllInventoryItems() {\r\n  const supabase = await createSupabaseServerClient();\r\n  \r\n  const { data, error } = await supabase\r\n    .from(\"inventory_items\")\r\n    .select(\"*\")\r\n    .eq(\"item_type\", \"finished_good\")\r\n    .gt(\"stock_level\", 0)\r\n    .order(\"item_name\", { ascending: true });\r\n\r\n  if (error) {\r\n    return { success: false, error: error.message, data: [] };\r\n  }\r\n\r\n  return { success: true, data };\r\n}\r\n\r\nexport async function getDeliveryAgents() {\r\n  const supabase = await createSupabaseServerClient();\r\n  \r\n  const { data, error } = await supabase\r\n    .from(\"profiles\")\r\n    .select(\"id, full_name, role\")\r\n    .eq(\"role\", \"delivery_agent\")\r\n    .order(\"full_name\", { ascending: true });\r\n\r\n  if (error) {\r\n    return { success: false, error: error.message, data: [] };\r\n  }\r\n\r\n  return { success: true, data };\r\n}\r\n"
        }
    ]
}