{
    "sourceFile": "lib/analytics.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1763069565216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1763069565216,
            "name": "Commit-0",
            "content": "import {\r\n  addDays,\r\n  differenceInDays,\r\n  differenceInHours,\r\n  isAfter,\r\n  isBefore,\r\n  isWithinInterval,\r\n  subDays,\r\n} from \"date-fns\";\r\nimport type {\r\n  Customer,\r\n  DeliveryAssignment,\r\n  InventoryItem,\r\n  Order,\r\n  PipelineAlert,\r\n} from \"@/types\";\r\n\r\nconst PRODUCT_LITERS: Record<string, number> = {\r\n  \"inv-oil-1l\": 1,\r\n  \"inv-oil-5l\": 5,\r\n  \"inv-oil-15l\": 15,\r\n};\r\n\r\nexport function calculateNextRefillDate(totalLiters: number, familySize: Customer[\"familySize\"], fromDate: Date) {\r\n  const monthlyConsumption = familySize === \"small\" ? 1 : familySize === \"large\" ? 3 : 2;\r\n  if (totalLiters <= 0 || monthlyConsumption <= 0) return null;\r\n\r\n  const monthsOfSupply = totalLiters / monthlyConsumption;\r\n  const daysOfSupply = Math.max(Math.round(monthsOfSupply * 30), 7);\r\n  return addDays(fromDate, daysOfSupply);\r\n}\r\n\r\nexport function litersFromOrder(order: Order) {\r\n  return order.items.reduce((acc, item) => acc + (PRODUCT_LITERS[item.productId] ?? 0) * item.quantity, 0);\r\n}\r\n\r\nexport function getLatestDeliveredOrder(orderHistory: Order[], customerId: string) {\r\n  const delivered = orderHistory\r\n    .filter((order) => order.customerId === customerId && order.status === \"delivered\" && order.deliveredAt)\r\n    .sort((a, b) => (a.deliveredAt! < b.deliveredAt! ? 1 : -1));\r\n  return delivered[0] ?? null;\r\n}\r\n\r\nexport function buildPipelineAlerts(params: {\r\n  customers: Customer[];\r\n  orders: Order[];\r\n  inventory: InventoryItem[];\r\n  assignments: DeliveryAssignment[];\r\n}): PipelineAlert[] {\r\n  const { customers, orders, inventory, assignments } = params;\r\n  const alerts: PipelineAlert[] = [];\r\n  const now = new Date();\r\n\r\n  customers.forEach((customer) => {\r\n    const statusAgeHours = differenceInHours(now, new Date(customer.lastInteractionAt));\r\n\r\n    if (customer.status === \"inquiry\" && statusAgeHours > 2) {\r\n      alerts.push({\r\n        id: `alert-nurture-${customer.id}`,\r\n        type: \"nurture\",\r\n        severity: \"warning\",\r\n        message: `${customer.name} has been waiting since inquiry. Send Health Benefits info now.`,\r\n        relatedCustomerId: customer.id,\r\n        dueAt: customer.lastInteractionAt,\r\n      });\r\n    }\r\n\r\n    if (customer.status === \"price_sent\" && statusAgeHours > 24) {\r\n      alerts.push({\r\n        id: `alert-trust-${customer.id}`,\r\n        type: \"nurture\",\r\n        severity: \"warning\",\r\n        message: `${customer.name} hasn\\'t moved after price. Share process video to build trust.`,\r\n        relatedCustomerId: customer.id,\r\n        dueAt: customer.lastInteractionAt,\r\n      });\r\n    }\r\n\r\n    const latestDelivery = getLatestDeliveredOrder(orders, customer.id);\r\n    if (customer.status === \"feedback_pending\" && latestDelivery?.deliveredAt) {\r\n      const deliveredAt = new Date(latestDelivery.deliveredAt);\r\n      if (differenceInDays(now, deliveredAt) >= 5) {\r\n        alerts.push({\r\n          id: `alert-feedback-${customer.id}`,\r\n          type: \"retention\",\r\n          severity: \"info\",\r\n          message: `Collect taste feedback from ${customer.name}.`,\r\n          relatedCustomerId: customer.id,\r\n          dueAt: latestDelivery.deliveredAt,\r\n        });\r\n      }\r\n    }\r\n\r\n    if (customer.nextRefillDate) {\r\n      const refillDate = new Date(customer.nextRefillDate);\r\n      const dueSoon = isWithinInterval(refillDate, { start: now, end: addDays(now, 3) });\r\n      if (dueSoon || isBefore(refillDate, now) || customer.status === \"refill_due\") {\r\n        alerts.push({\r\n          id: `alert-refill-${customer.id}`,\r\n          type: \"retention\",\r\n          severity: dueSoon ? \"warning\" : \"info\",\r\n          message: `Refill reminder for ${customer.name}.` ,\r\n          relatedCustomerId: customer.id,\r\n          dueAt: customer.nextRefillDate,\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  inventory.forEach((item) => {\r\n    if (item.stockLevel < item.lowStockThreshold) {\r\n      alerts.push({\r\n        id: `alert-inventory-${item.id}`,\r\n        type: \"inventory\",\r\n        severity: \"critical\",\r\n        message: `${item.itemName} is below safety stock.`,\r\n        dueAt: new Date().toISOString(),\r\n      });\r\n    }\r\n  });\r\n\r\n  assignments.forEach((assignment) => {\r\n    const order = orders.find((o) => o.id === assignment.orderId);\r\n    if (!order) return;\r\n\r\n    if (order.status === \"out_for_delivery\" && order.deliveryAgentId) {\r\n      const scheduled = new Date(assignment.scheduledFor);\r\n      if (isBefore(scheduled, subDays(now, 1))) {\r\n        alerts.push({\r\n          id: `alert-delivery-${order.id}`,\r\n          type: \"delivery\",\r\n          severity: \"warning\",\r\n          message: `Follow up with ${assignment.agentName} for Order ${order.id}.`,\r\n          relatedOrderId: order.id,\r\n          dueAt: assignment.scheduledFor,\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  return alerts;\r\n}\r\n\r\nexport function summarizeFinancials(orders: Order[], expenses: { amount: number }[]) {\r\n  const income = orders\r\n    .filter((order) => order.status === \"delivered\")\r\n    .reduce((acc, order) => acc + order.totalAmount, 0);\r\n\r\n  const expenseTotal = expenses.reduce((acc, expense) => acc + expense.amount, 0);\r\n\r\n  return {\r\n    income,\r\n    expenses: expenseTotal,\r\n    net: income - expenseTotal,\r\n  };\r\n}\r\n\r\nexport function summarizeOrderPipeline(orders: Order[]) {\r\n  const openOrders = orders.filter((order) => order.status !== \"delivered\");\r\n  const deliveredToday = orders.filter((order) => {\r\n    if (!order.deliveredAt) return false;\r\n    const delivered = new Date(order.deliveredAt);\r\n    return isAfter(delivered, subDays(new Date(), 1));\r\n  });\r\n\r\n  return {\r\n    openCount: openOrders.length,\r\n    deliveredToday: deliveredToday.length,\r\n    pendingCodCollections: orders.filter((order) => order.paymentStatus === \"cod\" && order.status === \"delivered\").length,\r\n  };\r\n}\r\n\r\nexport function ordersByDeliveryAgent(orders: Order[], agentId: string) {\r\n  return orders\r\n    .filter((order) => order.deliveryAgentId === agentId && order.status !== \"delivered\")\r\n    .sort((a, b) => (a.orderedAt > b.orderedAt ? -1 : 1));\r\n}\r\n"
        }
    ]
}